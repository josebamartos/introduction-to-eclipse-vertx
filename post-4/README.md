# [Post 3] Some Rest with Vert.x

Based on [Accessing Data – The Reactive Way](https://developers.redhat.com/blog/2018/04/09/accessing-data-reactive-way/) written by [Clement Escoffier](https://developers.redhat.com/blog/author/cescoffier/).

All the exercises are supossing that their root directory is `post-4`.

The application is running an in-memory back-end using a `LinkedHashMap` to store the articles and it can't persist the information. We will use a `PostgreSQL` database and for testing `HSQL`. Interactions with the database are asynchronous and made using the `vertx-jdbc-client`. But before diving into these JDBC and SQL details, let’s introduce the Vert.x `Future` class and explain how it’s going to make asynchronous coordination much simpler.


## Add Maven dependencies

Add the following dependencies (`Vert.x JDBC client` and `PostgreSQL JDBC driver)` to `pom.xml` file:

```xml
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-jdbc-client</artifactId>
  <version>${vertx.version}</version>
</dependency>
<dependency>
  <groupId>org.postgresql</groupId>
  <artifactId>postgresql</artifactId>
  <version>9.4.1212</version>
</dependency>
```


## Initialize JDBC client

Add configuration parmeters related to `PostgreSQL` server into `src/main/conf/my-application-conf.json` file:

```xml
{
  "HTTP_PORT": 8082,
 
  "url": "jdbc:postgresql://localhost:5432/my_read_list",
  "driver_class": "org.postgresql.Driver",
  "user": "user",
  "password": "password"
}
```

In `MyFirstVerticle` class, declare a new field `jdbc` (`JDBCClient`). The end of the `start()` method will be like the code block below:

```java
ConfigRetriever retriever = ConfigRetriever.create(vertx);
retriever.getConfig(
    config -> {
        if (config.failed()) {
            fut.fail(config.cause());
        } else {
            // Create the JDBC client
            jdbc = JDBCClient.createShared(vertx, config.result(), "My-Reading-List");
                // Create the HTTP server and pass the
                // "accept" method to the request handler.
                vertx
                   .createHttpServer()
                   .requestHandler(router::accept)
                   .listen(
                       // Retrieve the port from the
                       // configuration, default to 8080.
                       config().getInteger("HTTP_PORT", 8080),
                           result -> {
                               if (result.succeeded()) {
                                   fut.complete();
                               } else {
                                   fut.fail(result.cause());
                               }
                           }
                       );
         }
     }
);
```

Ok, we have the client configured with our configuration, we need a connection to the database. This is achieved using the `jdbc.getConnection()` method that provides its result (the connection) to a `Handler<AsyncResult>`. This handler is notified when the connection with the database is established or if something bad happens during the process. While we could use the method directly, let’s extract the retrieval of a connection to a separate method and returns a Future:

```java
private Future<SQLConnection> connect() {
    Future<SQLConnection> future = Future.future();
    jdbc.getConnection(ar ->
        future.handle(ar.map(connection ->
            connection.setOptions(
                new SQLOptions().setAutoGeneratedKeys(true))
            )
        )
    );
    return future;
}
```

Let’s have a deeper look to this method. First we create a `Future` object that we return at the end of the method. This Future will be completed or failed depending wether or not we successfully retrieve a connection to the database. The function we passed to `getConnection` receives an `AsyncResult`. `Future` have a method (`handle()`) to directly completes or fails based on an AsyncResult. To `handle` is equivalent to:

```java	
if (ar.failed()) {
  future.failed(ar.cause());
} else {
  future.complete(ar.result());
}
```

just… shorter.

However, before passing the AsyncResult to future, we want to configure the connection to enable the key generation. For this, we use the AsyncResult.map method. This method creates another instance of AsyncResult based on the given one and applies a mapper function on the result. If the given one encapsulates a failure, the created one encapsulate the same failure. If the input is a success, the mapper function is applied on the result.

## We Need Articles

Now that we have a JDBC client, and a way to retrieve a connection to the database it’s time to insert articles. But because we use a relational database, we first need to create the table. Create the following method:

```java
private Future<SQLConnection> createTableIfNeeded(SQLConnection connection) {
    Future<SQLConnection> future = Future.future();
    vertx.fileSystem().readFile("tables.sql", ar -> {
        if (ar.failed()) {
            future.fail(ar.cause());
        } else {
            connection.execute(ar.result().toString(),
                ar2 -> future.handle(ar2.map(connection))
            );
        }
    });
    return future;
}
```

The method also returns a `Future`. Attentive readers would spot that this is typically a method we can use in a `Future.compose` construct. This method body is quite simple. As usual, we create a `Future` and returns it at the end of the body. Then, we read the content of the `tables.sql` file and execute the unique statement contained in this file. The execute method takes the SQL statement as a parameter and invokes the given function with the result. In the handler, we complete or fail the future using the handle method. In this case, we want to complete the future with the database connection.

So, we need the `tables.sql` file. Creates the `src/main/resources/tables.sql` file with the following content:

```postgresql
CREATE TABLE IF NOT EXISTS Articles (id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    url VARCHAR(200) NOT NULL)
```

Ok, so now we have a connection to the database, and the table. Let’s insert articles, but only if the database is empty. For this, create the `createSomeDataIfNone()` and insert methods:

```java
private Future<SQLConnection> createSomeDataIfNone(SQLConnection connection) {
    Future<SQLConnection> future = Future.future();
    connection.query("SELECT * FROM Articles", select -> {
        if (select.failed()) {
            future.fail(select.cause());
        } else {
            if (select.result().getResults().isEmpty()) {
                Article article1 = new Article("Fallacies of distributed computing",
                    "https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing");
                Article article2 = new Article("Reactive Manifesto",
                    "https://www.reactivemanifesto.org/");
                Future<Article> insertion1 = insert(connection, article1, false);
                Future<Article> insertion2 = insert(connection, article2, false);
                CompositeFuture.all(insertion1, insertion2)
                    .setHandler(r -> future.handle(r.map(connection)));
            } else {
                future.complete(connection);
            }
        }
    });
    return future;
}

private Future<Article> insert(SQLConnection connection, Article article, boolean closeConnection) {
    Future<Article> future = Future.future();
    String sql = "INSERT INTO Articles (title, url) VALUES (?, ?)";
    connection.updateWithParams(sql,
        new JsonArray().add(article.getTitle()).add(article.getUrl()),
        ar -> {
            if (closeConnection) {
                connection.close();
            }
            future.handle(
                ar.map(res -> new Article(res.getKeys().getLong(0), article.getTitle(), article.getUrl()))
            );
        }
    );
    return future;
}
```

Let’s start by the end and the `insert()` method. It follows the same pattern and uses the `updateWithParams()` method to insert an article into the database. The SQL statement contains parameters injected using a JSON Array. Notice that the order of the parameter matters. When the insertion is done (in the handler), we close the connection if requested (closeConnection parameter) – this is because we are going to reuse method later. Finally, we complete or fail the future with, on success, a new `Article` containing the generated `id`. So, if the insertion failed, we just forward the failure to the future. If the insertion succeeds, we map it to an `Article` and complete the future with this value.

Ok, let’s switch to the `createSomeDataIfNone()` method. Again same pattern. But here we need a bit of coordination. Indeed, we need to check whether the database is empty first and if so insert two articles. To check if the database is empty, we use `connection.query()` retrieving all the articles. If the result is not empty, we create two articles that we insert using the insert method. To execute these two insertions, we use the `CompositeFuture` construct. So both actions are executed in concurrently, and when both are done (or one fails) the `handler` is called. Notice that the connection is not closed.


## Putting These Pieces Together

It’s time to assemble these pieces and see how it works. The start method needs to be updated to execute the following action:

  1. Retrieve the configuration (already done).
  1. When the configuration is retrieved, create the JDBC client (already done).
  1. Retrieve a connection to the database.
  1. With this connection, create the table if they do not exist.
  1. With the same connection, check whether the database contains articles, if not, insert some data.
  1. Close the connection.
  1. Start the HTTP server as we are ready to serve.
  1. Report the success or failure of the boot process to fut.

Wow… that’s a lot of actions. Fortunately, we have implemented almost all the required method in a way we can use Future composition. In the start method, replace the end of the code with:

```java	
// Start sequence:
// 1 - Retrieve the configuration
//  |- 2 - Create the JDBC client
//  |- 3 - Connect to the database (retrieve a connection)
//          |- 4 - Create table if needed
//               |- 5 - Add some data if needed
//                      |- 6 - Close connection when done
//          |- 7 - Start HTTP server
//  |- 8 - we are done!
ConfigRetriever.getConfigAsFuture(retriever)
    .compose(config -> {
        jdbc = JDBCClient.createShared(vertx, config, "My-Reading-List");
        return connect()
            .compose(connection -> {
                Future<Void> future = Future.future();
                createTableIfNeeded(connection)
            .compose(this::createSomeDataIfNone)
            .setHandler(x -> {
                connection.close();
                future.handle(x.mapEmpty());
            });
            return future;
        })
        .compose(v -> createHttpServer(config, router));
      }).setHandler(fut);
```

Don’t worry about the `createHttpServer()` method. We will cover it shortly. The code starts by retrieving the configuration and creates the `JDBCClient`. Then, we retrieve a database connection and initialize our database. Notice that the connection is close in all cases (even failures). When the database is set up, we start the HTTP server. Finally, when everything is done, we report the result (success or failure) to the fut telling to Vert.x whether or not we are ready to work.

Note about closing connections: Don’t forget to close the SQL connection when you are done. The connection will be given back to the connection pool and be recycled.

The `createHTTPServer` method is quite simple and follows the same pattern:

```java
private Future<Void> createHttpServer(JsonObject config, Router router) {
    Future<Void> future = Future.future();
    vertx
        .createHttpServer()
        .requestHandler(router::accept)
        .listen(
            config.getInteger("HTTP_PORT", 8080),
            res -> future.handle(res.mapEmpty())
        );
    return future;
}
```

Notice the `mapEmpty`. The method returns a `Future`, as we don’t care of the HTTP Server. To create an `AsyncResult` from an `AsyncResult` use the `mapEmpty` method, discarding the encapsulated result.


## Implementing the REST API On Top of JDBC

So, at this point, we have everything setup, but our API is still relying on our in-memory back-end. It’s time to re-implement our REST API on top of JDBC. But first, we need some utility methods focusing on the interaction with the database. These methods have been extracted to ease the understanding.

First, let’s add the query method:

```java
private Future<List<Article>> query(SQLConnection connection) {
    Future<List<Article>> future = Future.future();
    connection.query("SELECT * FROM articles", result -> {
        connection.close();
        future.handle(
            result.map(rs -> rs.getRows().stream().map(Article::new).collect(Collectors.toList()))
        );
    });
    return future;
}
```

This method uses again the same pattern: it creates a `Future` object and returns it. The future is completed or failed when the underlying action completes or fails. Here the action is a database query. The method executes the query and upon success, for each row creates a new `Article`. Also, notice that we close the connection regardless the success or failure of the query. It’s important to release the connection, so it can be recycled.

In the same vein, let’s implement queryOne:

```java
private Future<Article> queryOne(SQLConnection connection, String id) {
    Future<Article> future = Future.future();
    String sql = "SELECT * FROM articles WHERE id = ?";
    connection.queryWithParams(sql, new JsonArray().add(Integer.valueOf(id)), result -> {
        connection.close();
        future.handle(
            result.map(rs -> {
                List<JsonObject> rows = rs.getRows();
                if (rows.size() == 0) {
                    throw new NoSuchElementException("No article with id " + id);
                } else {
                    JsonObject row = rows.get(0);
                    return new Article(row);
                }
            })
        );
    });
    return future;
}
```

This method uses `queryWithParams` to inject the article id in the query. In the result handler, there is a bit more work as we need to check if the article has been found. If not, we throw a `NoSuchElementException` that would fail the future. This lets us generate 404 responses.

We have done queries, we need methods to update and delete. Here they are:

```java
private Future<Void> update(SQLConnection connection, String id, Article article) {
    Future<Void> future = Future.future();
    String sql = "UPDATE articles SET title = ?, url = ? WHERE id = ?";
    connection.updateWithParams(sql, new JsonArray()
        .add(article.getTitle())
        .add(article.getUrl())
        .add(Integer.valueOf(id)),
    ar -> {
        connection.close();
        if (ar.failed()) {
            future.fail(ar.cause());
        } else {
            UpdateResult ur = ar.result();
            if (ur.getUpdated() == 0) {
                future.fail(new NoSuchElementException("No article with id " + id));
            } else {
                future.complete();
            }
         }
    });
  return future;
}
 
private Future<Void> delete(SQLConnection connection, String id) {
    Future<Void> future = Future.future();
    String sql = "DELETE FROM Articles WHERE id = ?";
    connection.updateWithParams(sql,
        new JsonArray().add(Integer.valueOf(id)),
        ar -> {
            connection.close();
            if (ar.failed()) {
                future.fail(ar.cause());
            } else {
                if (ar.result().getUpdated() == 0) {
                    future.fail(
                    new NoSuchElementException("No article with id " + id));
                } else {
                    future.complete();
                }
            }
        });
    return future;
}
```

They are very similar and follow the same pattern (again!).

That’s great but it does not implement our REST API. So, let’s focus on this now. Just to refresh our mind, here are the methods we need to update:

  - `getAll` returns all the articles.
  - `addOne` inserts a new article. Article details are given in the request body.
  - `deleteOne` deletes a specific article. The id is given as a path parameter.
  - `getOne` provides the JSON representation of a specific article. The id is given as a path parameter.
  - `updateOne` updates a specific article. The id is given as a path parameter. The new details are in the request body.

Because we have extracted the database interactions in their own method, implementing this method is straightforward. For instance, the getAll method is:

```java
private void getAll(RoutingContext rc) {
    connect()
        .compose(this::query)
        .setHandler(ok(rc));
}
```

We retrieve a connection using the `connect()` method. Then we compose (sequential composition) this with the query method, and we attach a handler. This handler is `ok(rc)` which is provided in the `ActionHelper` class. It basically provides the JSON representation or manages the error responses (500, 404).

Following the same pattern, the other methods are implemented as follows:

```java
private void addOne(RoutingContext rc) {
  Article article = rc.getBodyAsJson().mapTo(Article.class);
  connect()
    .compose(connection -> insert(connection, article, true))
    .setHandler(created(rc));
}

private void deleteOne(RoutingContext rc) {
  String id = rc.pathParam("id");
  connect()
    .compose(connection -> delete(connection, id))
    .setHandler(noContent(rc));
}

private void getOne(RoutingContext rc) {
  String id = rc.pathParam("id");
  connect()
    .compose(connection -> queryOne(connection, id))
    .setHandler(ok(rc));
}

private void updateOne(RoutingContext rc) {
  String id = rc.request().getParam("id");
  Article article = rc.getBodyAsJson().mapTo(Article.class);
  connect()
    .compose(connection ->  update(connection, id, article))
    .setHandler(noContent(rc));
}
```

## Test, Test, and Test Again

If we run the application tests right now, it fails. First, we need to update the configuration to pass the JDBC URL and related details. But wait… we also need a database. We don’t necessarily want to use `PostgreSQL` in our unit test. Let’s use `HSQL`, an in-memory database. To do that we first need to add the following dependency in the `pom.xml`:

```xml	
<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.4.0</version>
    <scope>test</scope>
</dependency>
```

But wait, if you already use JDBC or database in general, you know that each database uses a different dialect (that’s the power of standards). Here, we can’t use the same table creation statement because `HSQL` does not understand the `PostgreSQL` dialect. So create the `src/test/resources/tables.sql` with the following content:

```hsqldb	
CREATE TABLE IF NOT EXISTS Articles (id INTEGER IDENTITY,
    title VARCHAR(200),
    url VARCHAR(200))
```

It’s the equivalent statement in the `HSQL` dialect. How would that work? When Vert.x reads a file it also checks the classpath (and `src/test/resources` is included in the test classpath). When running test, this file superseds the initial file we created.

We need to slightly update our tests to configure the `JDBCClient`. In the `MyFirstVerticleTest` class, change the `DeploymentOption` object created in the `setUp()` method to be:

```java	
DeploymentOptions options = new DeploymentOptions()
    .setConfig(new JsonObject()
        .put("HTTP_PORT", port)
        .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
        .put("driver_class", "org.hsqldb.jdbcDriver")
);
```

In addition to the `HTTP_PORT`, we also put the JDBC url and the class of the JDBC driver.

Now, you should be able to run the test with:

```text
$ mvn clean test
```

Showtime

This time we want to use a PostgreSQL instance. I’m going to use docker but use your favorite approach. With docker, I start my instance as follows:

```text	
docker run --name psql-client -e POSTGRES_USER=user \
    -e POSTGRES_PASSWORD=password \
    -e POSTGRES_DB=my_read_list \
    -p 5432:5432 -d postgres
```

Let’s now run our application:

```text
$ mvn compile vertx:run
```

Open your browser to [localhost:8082/assets/index.html](http://localhost:8082/assets/index.html), and you
should see the application using the database. This time the products are stored in a database persisted on the file system. So, if we stop and restart the application, the data is restored.

If you want to package the application, run mvn clean package. Then run the application using:

```text
java -jar target/my-first-app-1.0-SNAPSHOT.jar \
    -conf src/main/conf/my-application-conf.json
```

## Conclusion

This fourth post in our series has covered two topics. First, we have introduced asynchronous composition and how Future helps to manage sequential and concurrent composition. With Future, you follow a common pattern in your implementation, which is quite straightforward once you get it. Secondly, we have seen how JDBC can be used to implement our API. Because we use Future, using asynchronous JDBC is quite simple.

You may have been surprised by the asynchronous development model, but once you start using it, it’s hard to come back. Asynchronous and event-driven architecture represents how the world around us works. Embracing these give you superpowers.

In the next post, we will see how RX Java 2 can be used instead of Future. Don’t forget that the code is available in this Github repository.

Stay tuned, and happy coding!